// Generated by CoffeeScript 1.3.3
(function() {
  var CharCursor, Cursor, Lexer, OPERATORS, SyntaxError, WHITESPACE,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Cursor = require("./cursor");

  WHITESPACE = [' ', '\t'];

  OPERATORS = ['=', '+', '-', '*', '/', '<', '>', '%', '&', '(', ')', '[', ']', '^', ':', '?', '.'];

  SyntaxError = (function(_super) {

    __extends(SyntaxError, _super);

    function SyntaxError() {
      return SyntaxError.__super__.constructor.apply(this, arguments);
    }

    return SyntaxError;

  })(Error);

  CharCursor = (function(_super) {

    __extends(CharCursor, _super);

    function CharCursor(input) {
      var acc, line, _i, _len, _ref;
      this.input = input;
      this.indent = __bind(this.indent, this);

      this.at = __bind(this.at, this);

      CharCursor.__super__.constructor.call(this);
      this.input = this.input.replace("\r", "");
      this.lines = this.input.split("\n");
      this.line_ends = [];
      this.indents = [];
      acc = 0;
      _ref = this.lines;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        acc += line.length;
        this.line_ends.push(acc);
        if (acc < this.input.length) {
          acc += 1;
        }
      }
      if (acc !== this.input.length) {
        throw new Error("Tracking went wrong " + acc + ", " + this.input.length);
      }
    }

    CharCursor.prototype.at = function(index) {
      var line;
      if (index < 0 || index >= this.input.length) {
        return void 0;
      }
      line = 0;
      while (index > this.line_ends[line]) {
        line++;
      }
      return {
        line: line,
        column: index - (line > 0 ? this.line_ends[line - 1] + 1 : 0),
        char: this.input[index]
      };
    };

    CharCursor.prototype.indent = function(index) {
      var indent, line, _ref;
      line = 0;
      while (line < this.line_ends.length && index > this.line_ends[line]) {
        line++;
      }
      indent = this.indents[line] != null ? this.indents[line] : 0;
      if (indent === 0) {
        while (_ref = this.lines[line][indent], __indexOf.call(WHITESPACE, _ref) >= 0) {
          indent++;
        }
      }
      return indent;
    };

    return CharCursor;

  })(Cursor);

  module.exports = Lexer = (function(_super) {

    __extends(Lexer, _super);

    Lexer.CharCursor = CharCursor;

    function Lexer(input) {
      this.input = input;
      this.next_token = __bind(this.next_token, this);

      this.at = __bind(this.at, this);

      Lexer.__super__.constructor.call(this);
      this.char_index = 0;
      this.memo_index = -1;
      this.memos = [];
      this.linestart = true;
      this.indent = 0;
      this.char_cursor = new CharCursor(this.input);
    }

    Lexer.prototype.at = function(req_index) {
      while (this.memo_index < req_index) {
        if (!this.memos[this.memo_index += 1]) {
          this.memos[this.memo_index] = this.next_token();
        }
      }
      return this.memos[req_index];
    };

    Lexer.prototype.next_token = function() {
      var boundary, buffer, c, indent, line, lookahead, source, stack, tracking_start, type, ws, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      buffer = '';
      tracking_start = this.char_cursor.at(this.char_index);
      if (this.char_cursor.indent(this.char_index) > this.indent && this.input[this.char_index] !== "\n") {
        indent = this.char_cursor.indent(this.char_index);
        while (this.char_index < this.input.length && (this.char_cursor.indent(this.char_index) > this.indent)) {
          buffer += this.input[this.char_index];
          this.char_index++;
        }
        if (this.input[this.char_index - 1] === "\n") {
          this.char_index--;
          buffer = buffer.substr(0, buffer.length - 1);
        }
        source = ((function() {
          var _i, _len, _ref, _results;
          _ref = buffer.split("\n");
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            line = _ref[_i];
            _results.push(line.substr(indent));
          }
          return _results;
        })()).join("\n");
        return {
          type: 'block',
          token: buffer,
          source: source,
          tracking: {
            start: tracking_start,
            end: this.char_cursor.at(this.char_index - 1)
          }
        };
      }
      while (_ref = this.input[this.char_index], __indexOf.call(WHITESPACE, _ref) >= 0) {
        this.char_index += 1;
      }
      if (this.char_index >= this.input.length) {
        return null;
      }
      tracking_start = this.char_cursor.at(this.char_index);
      if ((_ref1 = this.input[this.char_index]) === "{" || _ref1 === "[" || _ref1 === "(") {
        stack = 1;
        buffer = this.input[this.char_index];
        this.char_index += 1;
        type = 'block';
        while (stack > 0 && this.char_index < this.input.length) {
          if ((_ref2 = this.input[this.char_index]) === "}" || _ref2 === "]" || _ref2 === ")") {
            stack -= 1;
          }
          if ((_ref3 = this.input[this.char_index]) === "{" || _ref3 === "[" || _ref3 === "(") {
            stack += 1;
          }
          buffer += this.input[this.char_index];
          this.char_index += 1;
        }
        if (stack > 0) {
          throw new SyntaxError("Unbalanced Parenthesis");
        }
        source = buffer.substring(1, buffer.length - 1);
        lookahead = 0;
        while (_ref4 = this.input[this.char_index + lookahead], __indexOf.call(WHITESPACE, _ref4) >= 0) {
          lookahead += 1;
        }
        if (this.input[this.char_index + lookahead] === "-" && this.input[this.char_index + lookahead + 1] === ">") {
          buffer += this.input.substr(this.char_index, lookahead + 2);
          this.char_index = this.char_index + lookahead + 2;
          type = 'function';
        }
        ws = 0;
        while (_ref5 = source[ws], __indexOf.call(WHITESPACE, _ref5) >= 0) {
          ws += 1;
        }
        source = source.substring(ws);
        if (source[0] === "\n") {
          source = source.substring(1);
          indent = 0;
          while (_ref6 = source[indent], __indexOf.call(WHITESPACE, _ref6) >= 0) {
            indent += 1;
          }
          source = ((function() {
            var _i, _len, _ref7, _results;
            _ref7 = source.split("\n");
            _results = [];
            for (_i = 0, _len = _ref7.length; _i < _len; _i++) {
              line = _ref7[_i];
              _results.push(line.substr(indent));
            }
            return _results;
          })()).join("\n");
        }
        return {
          type: type,
          token: buffer,
          source: source,
          tracking: {
            start: tracking_start,
            end: this.char_cursor.at(this.char_index - 1)
          }
        };
      }
      if (_ref7 = this.input[this.char_index], __indexOf.call(OPERATORS, _ref7) >= 0) {
        while (_ref8 = (c = this.input[this.char_index]), __indexOf.call(OPERATORS, _ref8) >= 0) {
          buffer += c;
          this.char_index += 1;
        }
        return {
          type: "operator",
          token: buffer,
          tracking: {
            start: tracking_start,
            end: this.char_cursor.at(this.char_index - 1)
          }
        };
      }
      if (/([a-zA-Z_@])/.test(this.input[this.char_index])) {
        c = this.input[this.char_index];
        while (true) {
          buffer += c;
          this.char_index += 1;
          if (!((c = this.input[this.char_index]) && /([a-zA-Z0-9_])/.test(c))) {
            break;
          }
        }
        return {
          type: "symbol",
          token: buffer,
          tracking: {
            start: tracking_start,
            end: this.char_cursor.at(this.char_index - 1)
          }
        };
      }
      if (/([0-9])/.test(this.input[this.char_index])) {
        while ((c = this.input[this.char_index]) && /([0-9]|\.|\,)/.test(c)) {
          buffer += c;
          this.char_index += 1;
        }
        if (this.input[this.char_index - 1] === ',') {
          buffer = buffer.substr(0, buffer.length - 1);
          this.char_index -= 1;
        }
        return {
          type: "number",
          token: buffer,
          value: parseFloat(buffer.replace(",", "")),
          tracking: {
            start: tracking_start,
            end: this.char_cursor.at(this.char_index - 1)
          }
        };
      }
      if ((_ref9 = this.input[this.char_index]) === "'" || _ref9 === '"') {
        boundary = this.input[this.char_index];
        this.char_index += 1;
        while ((c = this.input[this.char_index]) !== boundary) {
          buffer += c;
          this.char_index += 1;
          if ((c = this.input[this.char_index]) === "\\") {
            buffer += c;
            this.char_index += 1;
            buffer += c;
            this.char_index += 1;
          }
        }
        if (this.input[this.char_index] === boundary) {
          this.char_index += 1;
          return {
            type: "string",
            token: boundary + buffer + boundary,
            value: buffer,
            tracking: {
              start: tracking_start,
              end: this.char_cursor.at(this.char_index - 1)
            }
          };
        } else {
          throw new SyntaxError("Unterminated String");
        }
      }
      if (this.input[this.char_index] === "\n") {
        this.char_index += 1;
        return {
          type: 'linefeed',
          token: "\n",
          tracking: {
            start: tracking_start,
            end: this.char_cursor.at(this.char_index - 1)
          }
        };
      }
      throw new SyntaxError("Unknown token: " + this.input[this.char_index]);
    };

    return Lexer;

  })(Cursor);

}).call(this);

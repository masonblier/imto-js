// Generated by CoffeeScript 1.3.3
(function() {
  var CharCursor, Cursor, ImtoError, Lexer, OPERATORS, SyntaxError, WHITESPACE,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Cursor = require("./cursor");

  ImtoError = require('./utils').ImtoError;

  WHITESPACE = [' ', '\t'];

  OPERATORS = ['=', '+', '-', '*', '/', '<', '>', '%', '&', '^', ':', '?', '.'];

  SyntaxError = (function(_super) {

    __extends(SyntaxError, _super);

    function SyntaxError() {
      return SyntaxError.__super__.constructor.apply(this, arguments);
    }

    return SyntaxError;

  })(ImtoError);

  CharCursor = (function(_super) {

    __extends(CharCursor, _super);

    function CharCursor(input, options) {
      var acc, line, _i, _len, _ref, _ref1;
      this.input = input;
      this.indent = __bind(this.indent, this);

      this.at = __bind(this.at, this);

      CharCursor.__super__.constructor.call(this);
      this.input = this.input.replace("\r", "");
      this.length = this.input.length;
      this.lines = this.input.split("\n");
      this.line_ends = [];
      this.indents = [];
      acc = 0;
      if ((options != null ? (_ref = options.tracking) != null ? _ref.start : void 0 : void 0) != null) {
        this.offset = options.tracking.start;
      } else {
        this.offset = {
          line: 0,
          column: 0
        };
      }
      _ref1 = this.lines;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        line = _ref1[_i];
        acc += line.length;
        this.line_ends.push(acc);
        if (acc < this.input.length) {
          acc += 1;
        }
      }
      if (acc !== this.input.length) {
        throw new Error("Tracking went wrong " + acc + ", " + this.input.length);
      }
    }

    CharCursor.prototype.at = function(index) {
      var line;
      if (index < 0 || index >= this.input.length) {
        return void 0;
      }
      line = 0;
      while (index > this.line_ends[line]) {
        line++;
      }
      return {
        line: line + this.offset.line,
        column: index - (line > 0 ? this.line_ends[line - 1] + 1 : 0) + this.offset.column,
        char: this.input[index]
      };
    };

    CharCursor.prototype.indent = function(index) {
      var indent, line, _ref;
      line = 0;
      while (line < this.line_ends.length && index > this.line_ends[line]) {
        line++;
      }
      indent = this.indents[line] != null ? this.indents[line] : 0;
      if (indent === 0) {
        while (_ref = this.lines[line][indent], __indexOf.call(WHITESPACE, _ref) >= 0) {
          indent++;
        }
      }
      return indent;
    };

    return CharCursor;

  })(Cursor);

  module.exports = Lexer = (function(_super) {

    __extends(Lexer, _super);

    Lexer.CharCursor = CharCursor;

    function Lexer(input, options) {
      this.next_token = __bind(this.next_token, this);

      this.at = __bind(this.at, this);

      var _ref;
      Lexer.__super__.constructor.call(this);
      this.memo_index = -1;
      this.memos = [];
      this.linestart = true;
      this.indent = 0;
      this.char_cursor = new CharCursor(input, options);
      while (((_ref = this.char_cursor.peek()) != null ? _ref.char : void 0) === "\n") {
        this.char_cursor.next();
      }
    }

    Lexer.prototype.at = function(req_index) {
      while (this.memo_index < req_index) {
        if (!this.memos[this.memo_index += 1]) {
          this.memos[this.memo_index] = this.next_token();
        }
      }
      return this.memos[req_index];
    };

    Lexer.prototype.next_token = function() {
      var boundary, buffer, c, cc, i, indent, line, lookahead, source, stack, tracking_start, type, ws, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref18, _ref19, _ref2, _ref20, _ref21, _ref22, _ref23, _ref24, _ref25, _ref26, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      buffer = '';
      cc = this.char_cursor;
      ws = 1;
      while (_ref = (_ref1 = cc.peek(ws)) != null ? _ref1.char : void 0, __indexOf.call(WHITESPACE, _ref) >= 0) {
        ws += 1;
      }
      if (ws > 1 && ((_ref2 = cc.peek(ws)) != null ? _ref2.char : void 0) === "\n") {
        cc.next(ws);
      }
      while (((_ref3 = cc.peek()) != null ? _ref3.char : void 0) === "\n" && ((_ref4 = cc.peek(2)) != null ? _ref4.char : void 0) === "\n") {
        cc.next();
      }
      while (((_ref5 = cc.peek()) != null ? _ref5.char : void 0) === "\n" && cc.indent(cc.index + 1) > this.indent) {
        cc.next();
      }
      tracking_start = cc.peek();
      if ((cc.peek() != null) && cc.peek().char !== "\n" && cc.indent(cc.index) > this.indent) {
        indent = cc.indent(cc.index);
        tracking_start = cc.peek(indent + 1);
        while (cc.index < cc.length && (cc.indent(cc.index) > this.indent)) {
          buffer += cc.next().char;
        }
        if (((_ref6 = cc.prev(0)) != null ? _ref6.char : void 0) === "\n") {
          cc.back();
          buffer = buffer.substr(0, buffer.length - 1);
        }
        source = ((function() {
          var _i, _len, _ref7, _results;
          _ref7 = buffer.split("\n");
          _results = [];
          for (_i = 0, _len = _ref7.length; _i < _len; _i++) {
            line = _ref7[_i];
            _results.push(line.substr(indent));
          }
          return _results;
        })()).join("\n");
        return {
          type: 'block',
          token: buffer,
          source: source,
          tracking: {
            start: tracking_start,
            end: cc.peek(0)
          }
        };
      }
      while (_ref7 = (_ref8 = cc.peek()) != null ? _ref8.char : void 0, __indexOf.call(WHITESPACE, _ref7) >= 0) {
        cc.next();
      }
      if (!(cc.index < cc.length)) {
        return null;
      }
      tracking_start = cc.peek();
      if ((_ref9 = cc.peek().char) === "{" || _ref9 === "[" || _ref9 === "(") {
        stack = 1;
        source = cc.next();
        buffer = source.char;
        type = 'block';
        while (stack > 0 && cc.index < cc.length) {
          if ((_ref10 = cc.peek().char) === "}" || _ref10 === "]" || _ref10 === ")") {
            stack -= 1;
          }
          if ((_ref11 = cc.peek().char) === "{" || _ref11 === "[" || _ref11 === "(") {
            stack += 1;
          }
          buffer += cc.next().char;
        }
        if (stack > 0) {
          throw new SyntaxError("Unmatched Bracket", {
            tracking: source
          });
        }
        source = buffer.substring(1, buffer.length - 1);
        lookahead = 1;
        while (_ref12 = (_ref13 = cc.peek(lookahead)) != null ? _ref13.char : void 0, __indexOf.call(WHITESPACE, _ref12) >= 0) {
          lookahead += 1;
        }
        if ((((_ref14 = cc.peek(lookahead)) != null ? _ref14.char : void 0) === "-" || "=") && ((_ref15 = cc.peek(lookahead + 1)) != null ? _ref15.char : void 0) === ">") {
          buffer += ((function() {
            var _i, _ref16, _results;
            _results = [];
            for (i = _i = 0, _ref16 = lookahead + 1; 0 <= _ref16 ? _i <= _ref16 : _i >= _ref16; i = 0 <= _ref16 ? ++_i : --_i) {
              _results.push(cc.peek(i).char);
            }
            return _results;
          })()).join("");
          cc.index = cc.index + lookahead + 1;
          type = 'function';
        }
        ws = 0;
        while (_ref16 = source[ws], __indexOf.call(WHITESPACE, _ref16) >= 0) {
          ws += 1;
        }
        source = source.substring(ws);
        if (source[0] === "\n") {
          source = source.substring(1);
          indent = 0;
          while (_ref17 = source[indent], __indexOf.call(WHITESPACE, _ref17) >= 0) {
            indent += 1;
          }
          source = ((function() {
            var _i, _len, _ref18, _results;
            _ref18 = source.split("\n");
            _results = [];
            for (_i = 0, _len = _ref18.length; _i < _len; _i++) {
              line = _ref18[_i];
              _results.push(line.substr(indent));
            }
            return _results;
          })()).join("\n");
        }
        return {
          type: type,
          token: buffer,
          source: source,
          tracking: {
            start: tracking_start,
            end: cc.peek(0)
          }
        };
      }
      if (_ref18 = cc.peek().char, __indexOf.call(OPERATORS, _ref18) >= 0) {
        while (_ref19 = (_ref20 = cc.peek()) != null ? _ref20.char : void 0, __indexOf.call(OPERATORS, _ref19) >= 0) {
          buffer += cc.next().char;
        }
        return {
          type: "operator",
          token: buffer,
          tracking: {
            start: tracking_start,
            end: cc.peek(0)
          }
        };
      }
      if (/([a-zA-Z_@])/.test(cc.peek().char)) {
        buffer = cc.next().char;
        while ((cc.peek() != null) && /([a-zA-Z0-9_])/.test(cc.peek().char)) {
          buffer += cc.next().char;
        }
        return {
          type: "symbol",
          token: buffer,
          tracking: {
            start: tracking_start,
            end: cc.peek(0)
          }
        };
      }
      if (/([0-9])/.test(cc.peek().char)) {
        while ((cc.peek() != null) && /([0-9]|\.|\,)/.test(cc.peek().char)) {
          buffer += cc.next().char;
        }
        if (((_ref21 = cc.prev(0)) != null ? _ref21.char : void 0) === ',') {
          cc.back();
          buffer = buffer.substr(0, buffer.length - 1);
        }
        return {
          type: "number",
          token: buffer,
          value: parseFloat(buffer.replace(",", "")),
          tracking: {
            start: tracking_start,
            end: cc.peek(0)
          }
        };
      }
      if ((_ref22 = cc.peek().char) === "'" || _ref22 === '"') {
        boundary = cc.next().char;
        while ((cc.peek() != null) && ((_ref24 = cc.peek()) != null ? _ref24.char : void 0) !== boundary) {
          buffer += cc.next().char;
          if (((_ref23 = cc.peek()) != null ? _ref23.char : void 0) === "\\") {
            buffer += cc.next().char;
            buffer += cc.next().char;
          }
        }
        if (((_ref25 = cc.next()) != null ? _ref25.char : void 0) === boundary) {
          return {
            type: "string",
            token: "" + boundary + buffer + boundary,
            value: buffer,
            tracking: {
              start: tracking_start,
              end: cc.peek(0)
            }
          };
        } else {
          throw new SyntaxError("Unterminated String", {
            tracking: tracking_start
          });
        }
      }
      if (cc.peek().char === "#") {
        while (c = cc.next() != null) {
          if (c === "\n") {
            break;
          }
          buffer += c;
        }
        return {
          type: "comment",
          token: buffer,
          tracking: {
            start: tracking_start,
            end: cc.peek(0)
          }
        };
      }
      if (cc.peek().char === ",") {
        cc.next();
        return {
          type: 'comma',
          token: ",",
          tracking: {
            start: tracking_start,
            end: cc.peek(0)
          }
        };
      }
      if (cc.peek().char === "\n") {
        cc.next();
        return {
          type: 'linefeed',
          token: "\n",
          tracking: {
            start: tracking_start,
            end: cc.peek(0)
          }
        };
      }
      if ((_ref26 = cc.peek().char) === "]" || _ref26 === ")" || _ref26 === "}") {
        throw new SyntaxError("Umatched Bracket", {
          tracking: cc.next()
        });
      }
      throw new SyntaxError("Unknown token", {
        tracking: cc.next()
      });
    };

    return Lexer;

  })(Cursor);

}).call(this);

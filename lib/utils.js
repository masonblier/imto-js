// Generated by CoffeeScript 1.3.3
(function() {
  var clc, enableColours, sprint,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  enableColours = false;

  if (process.platform !== 'win32') {
    enableColours = !process.env.NODE_DISABLE_COLORS;
  }

  clc = enableColours ? require('cli-color') : {
    green: function(a) {
      return a;
    },
    blue: function(a) {
      return a;
    },
    red: function(a) {
      return a;
    }
  };

  global.ImtoError = (function(_super) {

    __extends(ImtoError, _super);

    function ImtoError(message, options) {
      this.message = message;
      this.toString = __bind(this.toString, this);

      ImtoError.__super__.constructor.call(this, message);
      if ((options != null ? options.tracking : void 0) != null) {
        this.tracking = options.tracking;
      }
    }

    ImtoError.prototype.toString = function() {
      if (this.tracking != null) {
        return "{" + this.tracking.line + "," + this.tracking.column + "} " + this.message;
      } else {
        return this.message;
      }
    };

    return ImtoError;

  })(Error);

  sprint = function(list, indent) {
    var head, node, nodes;
    if (indent == null) {
      indent = "";
    }
    return ((function() {
      var _i, _len, _ref, _ref1, _results;
      _results = [];
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        node = list[_i];
        head = "" + indent + "(" + (clc.green(node.type));
        if (node.type === "block") {
          _results.push("" + head + "\n" + (sprint(node.parse(), indent + "  ")) + "\n" + indent + ")");
        } else if (node.type === "function") {
          _results.push("" + head + "\n" + (sprint([node.body], indent + "  ")) + "\n" + indent + ")");
        } else if (node.type === "execute") {
          _results.push("" + head + " " + (clc.blue("" + node.symbol)) + (((_ref = node.params) != null ? _ref.length : void 0) > 0 ? "\n" + (sprint(node.params, indent + "  ")) + "\n" + indent : "") + ")");
        } else if (node.type === "hash") {
          _results.push("" + head + " " + (((_ref1 = node.statements) != null ? _ref1.length : void 0) > 0 ? "\n" + (sprint(node.statements, indent + "  ")) + "\n" + indent : "") + ")");
        } else if (node.type === "operator") {
          nodes = [node.left];
          if (node.right != null) {
            nodes.push(node.right);
          }
          _results.push("" + head + " " + (clc.blue("" + node.operator)) + "\n" + (sprint(nodes, indent + "  ")) + "\n" + indent + ")");
        } else if (node.type === "assignment" || node.type === "hash_assignment") {
          _results.push("" + head + " " + (clc.blue("" + node.symbol)) + "\n" + (sprint([node.value], indent + "  ")) + "\n" + indent + ")");
        } else if (node.type === "literal") {
          _results.push("" + head + " " + (clc.red(node.token)) + ")");
        } else {
          _results.push("" + head + " '" + node.token + "')");
        }
      }
      return _results;
    })()).join("\n");
  };

  module.exports = {
    ImtoError: ImtoError,
    clc: clc,
    printNode: function(node) {
      return sprint([node]);
    }
  };

}).call(this);

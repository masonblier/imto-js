// Generated by CoffeeScript 1.3.3
(function() {
  var Cursor, Lexer, ParseError, ParseNode, Parser, clc, parse, precedence, sprint,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Lexer = require('./lexer');

  Parser = require('./parser');

  Cursor = require('./Cursor');

  ParseError = (function(_super) {

    __extends(ParseError, _super);

    function ParseError() {
      return ParseError.__super__.constructor.apply(this, arguments);
    }

    return ParseError;

  })(ImtoError);

  parse = function(str, options) {
    if (str != null) {
      return (new Parser(new Lexer(str, options))).all();
    } else {
      return {};
    }
  };

  precedence = {
    "+": 1,
    ".": 2
  };

  clc = require('cli-color');

  sprint = function(list, indent) {
    var head, node;
    if (indent == null) {
      indent = "";
    }
    return ((function() {
      var _i, _len, _ref, _ref1, _results;
      _results = [];
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        node = list[_i];
        if (!node) {
          pp(list);
        }
        head = "" + indent + "(" + (clc.green(node.type));
        if (node.type === "block") {
          _results.push("" + head + "\n" + (sprint(parse(node.source, {
            tracking: node.tracking
          }), indent + "  ")) + "\n" + indent + ")");
        } else if (node.type === "function") {
          _results.push("" + head + "\n" + (sprint([node.body], indent + "  ")) + "\n" + indent + ")");
        } else if (node.type === "execute") {
          _results.push("" + head + " " + (clc.blue("" + node.symbol)) + (((_ref = node.params) != null ? _ref.length : void 0) > 0 ? "\n" + (sprint(node.params, indent + "  ")) + "\n" + indent : "") + ")");
        } else if (node.type === "hash") {
          _results.push("" + head + " " + (((_ref1 = node.statements) != null ? _ref1.length : void 0) > 0 ? "\n" + (sprint(node.statements, indent + "  ")) + "\n" + indent : "") + ")");
        } else if (node.type === "operator") {
          _results.push("" + head + " " + (clc.blue("" + node.operator)) + "\n" + (sprint([node.left, node.right], indent + "  ")) + "\n" + indent + ")");
        } else if (node.type === "assignment" || node.type === "hash_assignment") {
          _results.push("" + head + " " + (clc.blue("" + node.symbol)) + "\n" + (sprint([node.value], indent + "  ")) + "\n" + indent + ")");
        } else if (node.type === "literal") {
          _results.push("" + head + " " + (clc.red(node.token)) + ")");
        } else {
          _results.push("" + head + " '" + node.token + "')");
        }
      }
      return _results;
    })()).join("\n");
  };

  ParseNode = (function() {

    function ParseNode(options) {
      this.toString = __bind(this.toString, this);

      var p;
      for (p in options) {
        if (!__hasProp.call(options, p)) continue;
        this[p] = options[p];
      }
    }

    ParseNode.prototype.toString = function() {
      return sprint([this]);
    };

    return ParseNode;

  })();

  module.exports = Parser = (function(_super) {

    __extends(Parser, _super);

    function Parser(lexer) {
      this.lexer = lexer;
      this.execute = __bind(this.execute, this);

      this.local_assignment = __bind(this.local_assignment, this);

      this.hash_assignment = __bind(this.hash_assignment, this);

      this.assignment = __bind(this.assignment, this);

      this["function"] = __bind(this["function"], this);

      this.block = __bind(this.block, this);

      this.tidbit = __bind(this.tidbit, this);

      this.operator = __bind(this.operator, this);

      this.expr = __bind(this.expr, this);

      this.statement = __bind(this.statement, this);

      this.at = __bind(this.at, this);

      Parser.__super__.constructor.call(this);
      this.memo_index = -1;
      this.memos = [];
    }

    Parser.prototype.at = function(req_index) {
      while (this.memo_index < req_index) {
        if (!this.memos[this.memo_index += 1]) {
          this.memos[this.memo_index] = this.statement();
        }
      }
      return this.memos[req_index];
    };

    Parser.prototype.statement = function() {
      var expr, _ref;
      while (((_ref = this.lexer.peek()) != null ? _ref.type : void 0) === "linefeed") {
        this.lexer.next();
      }
      if (expr = this.expr()) {
        return new ParseNode(expr);
      } else {
        return void 0;
      }
    };

    Parser.prototype.expr = function() {
      var expr;
      expr = this.tidbit();
      expr = this.operator(expr) || expr;
      return expr;
    };

    Parser.prototype.operator = function(expr) {
      var node, operator, result;
      if ((expr != null) && (this.lexer.peek() != null) && this.lexer.peek().type === "operator") {
        operator = this.lexer.next();
        node = this.tidbit();
        if ((expr != null) && (this.lexer.peek() != null) && this.lexer.peek().type === "operator") {
          if ((precedence[this.lexer.peek().token] != null) && precedence[this.lexer.peek().token] > precedence[operator.token]) {
            node = this.operator(node);
          }
          result = {
            type: 'operator',
            left: expr,
            right: node,
            operator: operator.token,
            tracking: {
              start: expr.tracking.start,
              end: (node != null ? node : operator).tracking.end
            }
          };
          return this.operator(result) || result;
        }
        return {
          type: 'operator',
          left: expr,
          right: node,
          operator: operator.token,
          tracking: {
            start: expr.tracking.start,
            end: (node != null ? node : operator).tracking.end
          }
        };
      }
    };

    Parser.prototype.tidbit = function() {
      var expr;
      if (!expr) {
        expr = this.block() || this["function"]() || this.assignment() || this.execute() || (expr = this.lexer.next());
      }
      return expr;
    };

    Parser.prototype.block = function() {
      var n, subject, _ref, _ref1, _ref2;
      if (((_ref = this.lexer.peek()) != null ? _ref.type : void 0) === "block") {
        subject = this.lexer.next();
        return {
          type: "block",
          source: subject.source,
          tracking: {
            start: subject.tracking.start,
            end: subject.tracking.end
          }
        };
      }
      if (((_ref1 = this.lexer.peek()) != null ? _ref1.type : void 0) === "linefeed") {
        if (((_ref2 = this.lexer.peek(2)) != null ? _ref2.type : void 0) === "block") {
          subject = this.lexer.next(2);
          n = this.lexer.next();
          return {
            type: "block",
            source: n.source,
            tracking: {
              start: subject.tracking.start,
              end: n.tracking.end
            }
          };
        }
      }
    };

    Parser.prototype["function"] = function() {
      var node, subject, _ref;
      if (((_ref = this.lexer.peek()) != null ? _ref.type : void 0) === "function") {
        subject = this.lexer.next();
        node = this.expr();
        return {
          type: "function",
          body: node,
          signature: subject.source,
          tracking: {
            start: subject.tracking.start,
            end: node.tracking.end
          }
        };
      }
    };

    Parser.prototype.assignment = function() {
      return this.hash_assignment() || this.local_assignment();
    };

    Parser.prototype.hash_assignment = function() {
      var first, n, node, statements, subject, _ref, _ref1, _ref2;
      if (((_ref = this.lexer.peek()) != null ? _ref.type : void 0) === "symbol") {
        n = this.lexer.peek(2);
        if ((n != null ? n.token : void 0) === ":") {
          subject = this.lexer.next();
          this.lexer.next();
          node = this.expr();
          first = {
            type: "hash_assignment",
            symbol: subject.token,
            value: node,
            tracking: {
              start: subject.tracking.start,
              end: node.tracking.end
            }
          };
          if (((_ref1 = this.lexer.peek()) != null ? _ref1.token : void 0) === ',') {
            statements = [first];
            while (((_ref2 = this.lexer.peek()) != null ? _ref2.token : void 0) === ',') {
              this.lexer.next();
              node = this.hash_assignment();
              if (node == null) {
                throw new ParseError("Unfinished hash", {
                  tracking: this.lexer.prev(0).tracking.start
                });
              }
              statements.push(node);
            }
            return {
              type: "hash",
              statements: statements,
              tracking: {
                start: subject.tracking.start,
                end: node.tracking.end
              }
            };
          } else {
            return first;
          }
        }
      }
      return null;
    };

    Parser.prototype.local_assignment = function() {
      var n, node, subject, _ref;
      if (((_ref = this.lexer.peek()) != null ? _ref.type : void 0) === "symbol") {
        n = this.lexer.peek(2);
        if ((n != null ? n.token : void 0) === "=") {
          subject = this.lexer.next();
          this.lexer.next();
          node = this.expr();
          return {
            type: "assignment",
            symbol: subject.token,
            value: node,
            tracking: {
              start: subject.tracking.start,
              end: node.tracking.end
            }
          };
        }
      }
    };

    Parser.prototype.execute = function() {
      var expr, params, subject, _ref;
      if (((_ref = this.lexer.peek()) != null ? _ref.type : void 0) === "symbol") {
        subject = this.lexer.next();
        params = [];
        while ((this.lexer.peek() != null) && this.lexer.peek().token !== "\n") {
          expr = this.tidbit();
          if ((expr != null) && expr.type !== "operator") {
            params.push(expr);
          } else {
            this.lexer.back();
            break;
          }
          if (!((this.lexer.peek() != null) && this.lexer.peek().token === ",")) {
            break;
          }
          this.lexer.next();
        }
        return {
          type: 'execute',
          symbol: subject.token,
          params: params,
          tracking: {
            start: subject.tracking.start,
            end: (params.length > 0 ? params[params.length - 1] : subject).tracking.end
          }
        };
      }
    };

    return Parser;

  })(Cursor);

}).call(this);

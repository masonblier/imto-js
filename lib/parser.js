// Generated by CoffeeScript 1.3.3
(function() {
  var Cursor, Lexer, ParseNode, Parser, clc, parse, sprint,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Lexer = require('./lexer');

  Parser = require('./parser');

  Cursor = require('./Cursor');

  parse = function(str) {
    if (str != null) {
      return (new Parser(new Lexer(str))).all();
    } else {
      return {};
    }
  };

  clc = require('cli-color');

  sprint = function(list, indent) {
    var head, node;
    if (indent == null) {
      indent = "";
    }
    return ((function() {
      var _i, _len, _ref, _results;
      _results = [];
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        node = list[_i];
        head = "" + indent + "(" + (clc.green(node.type));
        if (node.type === "block") {
          _results.push("" + head + "\n" + (sprint(parse(node.source), indent + "  ")) + "\n" + indent + ")");
        } else if (node.type === "function") {
          _results.push("" + head + "\n" + (sprint([node.body], indent + "  ")) + "\n" + indent + ")");
        } else if (node.type === "execute") {
          _results.push("" + head + " " + (clc.blue("" + node.symbol)) + (node.operator != null ? " " + node.operator + " " : "") + (((_ref = node.params) != null ? _ref.length : void 0) > 0 ? "\n" + (sprint(node.params, indent + "  ")) + "\n" + indent : "") + ")");
        } else if (node.type === "assignment" || node.type === "property_assignment") {
          _results.push("" + head + " " + (clc.blue("" + node.symbol)) + "\n" + (sprint([node.value], indent + "  ")) + "\n" + indent + ")");
        } else if (node.type === "literal") {
          _results.push("" + head + " " + (clc.red(node.token)) + ")");
        } else {
          _results.push("" + head + " '" + node.token + "')");
        }
      }
      return _results;
    })()).join("\n");
  };

  ParseNode = (function() {

    function ParseNode(options) {
      this.toString = __bind(this.toString, this);

      var p;
      for (p in options) {
        if (!__hasProp.call(options, p)) continue;
        this[p] = options[p];
      }
    }

    ParseNode.prototype.toString = function() {
      console.log("tostringing ", this);
      return sprint([this]);
    };

    return ParseNode;

  })();

  module.exports = Parser = (function(_super) {

    __extends(Parser, _super);

    function Parser(lexer) {
      this.lexer = lexer;
      this.execute = __bind(this.execute, this);

      this.operator = __bind(this.operator, this);

      this.local_assignment = __bind(this.local_assignment, this);

      this.property_assignment = __bind(this.property_assignment, this);

      this.assignment = __bind(this.assignment, this);

      this["function"] = __bind(this["function"], this);

      this.block = __bind(this.block, this);

      this.expr = __bind(this.expr, this);

      this.statement = __bind(this.statement, this);

      this.at = __bind(this.at, this);

      Parser.__super__.constructor.call(this);
      this.memo_index = -1;
      this.memos = [];
    }

    Parser.prototype.at = function(req_index) {
      while (this.memo_index < req_index) {
        if (!this.memos[this.memo_index += 1]) {
          this.memos[this.memo_index] = this.statement();
        }
      }
      return this.memos[req_index];
    };

    Parser.prototype.statement = function() {
      var expr, subject;
      subject = this.lexer.next();
      while ((subject != null ? subject.type : void 0) === "linefeed") {
        subject = this.lexer.next();
      }
      if (expr = this.expr(subject)) {
        return new ParseNode(expr);
      } else {
        return void 0;
      }
    };

    Parser.prototype.expr = function(subject) {
      var expr;
      expr = this.block(subject) || this["function"](subject) || this.assignment(subject) || this.operator(subject) || this.execute(subject) || subject;
      return expr;
    };

    Parser.prototype.block = function(subject) {
      var n, _ref;
      if ((subject != null ? subject.type : void 0) === "block") {
        return {
          type: "block",
          source: subject.source,
          tracking: {
            start: subject.tracking.start,
            end: subject.tracking.end
          }
        };
      }
      if ((subject != null ? subject.type : void 0) === "linefeed") {
        if (((_ref = this.lexer.peek()) != null ? _ref.type : void 0) === "block") {
          n = this.lexer.next();
          return {
            type: "block",
            source: n.source,
            tracking: {
              start: subject.tracking.start,
              end: n.tracking.end
            }
          };
        }
      }
    };

    Parser.prototype["function"] = function(subject) {
      var node;
      if ((subject != null ? subject.type : void 0) === "function") {
        node = this.expr(this.lexer.next());
        return {
          type: "function",
          body: node,
          tracking: {
            start: subject.tracking.start,
            end: node.tracking.end
          }
        };
      }
    };

    Parser.prototype.assignment = function(subject) {
      return this.property_assignment(subject) || this.local_assignment(subject);
    };

    Parser.prototype.property_assignment = function(subject) {
      var n, node;
      if ((subject != null ? subject.type : void 0) === "symbol") {
        n = this.lexer.peek();
        if ((n != null ? n.token : void 0) === ":") {
          node = this.expr(this.lexer.next(2));
          return {
            type: "property_assignment",
            symbol: subject.token,
            value: node,
            tracking: {
              start: subject.tracking.start,
              end: node.tracking.end
            }
          };
        }
      }
      return null;
    };

    Parser.prototype.local_assignment = function(subject) {
      var n, node;
      if ((subject != null ? subject.type : void 0) === "symbol") {
        n = this.lexer.peek();
        if ((n != null ? n.token : void 0) === "=") {
          node = this.expr(this.lexer.next(2));
          return {
            type: "assignment",
            symbol: subject.token,
            value: node,
            tracking: {
              start: subject.tracking.start,
              end: node.tracking.end
            }
          };
        }
      }
    };

    Parser.prototype.operator = function(subject) {
      var node, value;
      if ((subject != null ? subject.type : void 0) === "operator") {
        node = this.expr(this.lexer.next());
        value = node ? node : void 0;
        return {
          type: "operator",
          operator: subject.token,
          value: value,
          tracking: {
            start: subject.tracking.start,
            end: (node != null ? node : subject).tracking.end
          }
        };
      }
    };

    Parser.prototype.execute = function(subject) {
      var expr, params;
      if ((subject != null ? subject.type : void 0) === "symbol") {
        params = [];
        while ((this.lexer.peek() != null) && this.lexer.peek().token !== "\n") {
          expr = this.expr(this.lexer.next());
          if (expr.type === "operator") {
            return {
              type: "execute",
              symbol: subject.token,
              operator: expr.operator,
              params: (expr.value != null ? [expr.value] : void 0),
              tracking: {
                start: subject.tracking.start,
                end: expr.tracking.end
              }
            };
          } else {
            params.push(expr);
          }
          if (!((this.lexer.peek() != null) && this.lexer.peek().token === ",")) {
            break;
          }
          this.lexer.next();
        }
        return {
          type: 'execute',
          symbol: subject.token,
          params: params,
          tracking: {
            start: subject.tracking.start,
            end: (params.length > 0 ? params[params.length - 1] : subject).tracking.end
          }
        };
      }
    };

    return Parser;

  })(Cursor);

}).call(this);

// Generated by CoffeeScript 1.3.3
(function() {
  var Lexer, Parser;

  Lexer = require('./lexer');

  Parser = function(lexer) {
    var ParserClass;
    ParserClass = (function() {

      function ParserClass(lexer) {
        this.lexer = lexer;
      }

      ParserClass.prototype.all = function() {
        var n, _results;
        _results = [];
        while (n = this.next()) {
          _results.push(n);
        }
        return _results;
      };

      ParserClass.prototype.next = function() {
        var subject;
        subject = this.lexer.next();
        while ((subject != null ? subject.type : void 0) === "linefeed") {
          subject = this.lexer.next();
        }
        return this.expr(subject);
      };

      ParserClass.prototype.expr = function(subject) {
        return this.block(subject) || this["function"](subject) || this.parenclosure(subject) || this.assignment(subject) || subject;
      };

      ParserClass.prototype.parenclosure = function(subject) {
        var inner, _ref;
        if ((subject != null ? subject.token : void 0) === "(") {
          inner = this.expr(this.lexer.next());
          if (((_ref = this.lexer.peek()) != null ? _ref.token : void 0) === ")") {
            this.lexer.next();
            return inner;
          } else {
            throw new Error("Invalid syntax");
          }
        }
      };

      ParserClass.prototype.block = function(subject) {
        var n, _ref;
        if ((subject != null ? subject.type : void 0) === "block") {
          return {
            type: "block",
            tree: Parser(Lexer(subject.source)).all()
          };
        }
        if ((subject != null ? subject.type : void 0) === "linefeed") {
          if (((_ref = this.lexer.peek()) != null ? _ref.type : void 0) === "block") {
            n = this.lexer.next();
            return {
              type: "block",
              tree: Parser(Lexer(n.source)).all()
            };
          }
        }
      };

      ParserClass.prototype["function"] = function(subject) {
        if ((subject != null ? subject.type : void 0) === "function") {
          return {
            type: "function",
            body: this.expr(this.lexer.next())
          };
        }
      };

      ParserClass.prototype.assignment = function(subject) {
        return this.property_assignment(subject) || this.local_assignment(subject);
      };

      ParserClass.prototype.property_assignment = function(subject) {
        var n;
        if ((subject != null ? subject.type : void 0) === "symbol") {
          n = this.lexer.peek();
          if ((n != null ? n.token : void 0) === ":") {
            return {
              type: "property_assignment",
              symbol: subject.token,
              value: this.expr(this.lexer.next(2))
            };
          }
        }
        return null;
      };

      ParserClass.prototype.local_assignment = function(subject) {
        var n;
        if ((subject != null ? subject.type : void 0) === "symbol") {
          n = this.lexer.peek();
          if ((n != null ? n.token : void 0) === "=") {
            return {
              type: "assignment",
              symbol: subject.token,
              value: this.expr(this.lexer.next(2))
            };
          }
        }
      };

      return ParserClass;

    })();
    return new ParserClass(lexer);
  };

  module.exports = Parser;

}).call(this);

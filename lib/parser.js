// Generated by CoffeeScript 1.3.3
(function() {
  var Lexer, Parser,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Lexer = require('./lexer');

  module.exports = Parser = (function() {

    function Parser(c) {
      this.local_assignment = __bind(this.local_assignment, this);

      this.property_assignment = __bind(this.property_assignment, this);

      this.assignment = __bind(this.assignment, this);

      this["function"] = __bind(this["function"], this);

      this.block = __bind(this.block, this);

      this.parenclosure = __bind(this.parenclosure, this);

      this.expr = __bind(this.expr, this);

      this.next = __bind(this.next, this);

      this.all = __bind(this.all, this);
      this.cursor = c;
    }

    Parser.prototype.all = function() {
      var n, _results;
      _results = [];
      while (n = this.next()) {
        _results.push(n);
      }
      return _results;
    };

    Parser.prototype.next = function() {
      var subject;
      subject = this.cursor.next();
      while ((subject != null ? subject.type : void 0) === "linefeed") {
        subject = this.cursor.next();
      }
      return this.expr(subject);
    };

    Parser.prototype.expr = function(subject) {
      return this.block(subject) || this["function"](subject) || this.parenclosure(subject) || this.assignment(subject) || subject;
    };

    Parser.prototype.parenclosure = function(subject) {
      var inner, _ref;
      if ((subject != null ? subject.token : void 0) === "(") {
        inner = this.expr(this.cursor.next());
        if (((_ref = this.cursor.peek()) != null ? _ref.token : void 0) === ")") {
          this.cursor.next();
          return inner;
        } else {
          throw new Error("Invalid syntax");
        }
      }
    };

    Parser.prototype.block = function(subject) {
      var n, _ref;
      if ((subject != null ? subject.type : void 0) === "block") {
        return {
          type: "block",
          tree: Parser(Lexer(subject.source).cursor()).all()
        };
      }
      if ((subject != null ? subject.type : void 0) === "linefeed") {
        if (((_ref = this.cursor.peek()) != null ? _ref.type : void 0) === "block") {
          n = this.cursor.next();
          return {
            type: "block",
            tree: Parser(Lexer(n.source).cursor()).all()
          };
        }
      }
    };

    Parser.prototype["function"] = function(subject) {
      if ((subject != null ? subject.type : void 0) === "function") {
        return {
          type: "function",
          body: this.expr(this.cursor.next())
        };
      }
    };

    Parser.prototype.assignment = function(subject) {
      return this.property_assignment(subject) || this.local_assignment(subject);
    };

    Parser.prototype.property_assignment = function(subject) {
      var n;
      if ((subject != null ? subject.type : void 0) === "symbol") {
        n = this.cursor.peek();
        if ((n != null ? n.token : void 0) === ":") {
          return {
            type: "property_assignment",
            symbol: subject.token,
            value: this.expr(this.cursor.next(2))
          };
        }
      }
      return null;
    };

    Parser.prototype.local_assignment = function(subject) {
      var n;
      if ((subject != null ? subject.type : void 0) === "symbol") {
        n = this.cursor.peek();
        if ((n != null ? n.token : void 0) === "=") {
          return {
            type: "assignment",
            symbol: subject.token,
            value: this.expr(this.cursor.next(2))
          };
        }
      }
    };

    return Parser;

  })();

}).call(this);

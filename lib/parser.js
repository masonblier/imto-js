// Generated by CoffeeScript 1.3.3
(function() {
  var BlockNode, Cursor, ImtoError, Lexer, ParseError, ParseNode, Parser, precedence, printNode, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Lexer = require('./lexer');

  Cursor = require('./cursor');

  _ref = require('./nodes'), ParseNode = _ref.ParseNode, BlockNode = _ref.BlockNode;

  _ref1 = require('./utils'), printNode = _ref1.printNode, ImtoError = _ref1.ImtoError;

  ParseError = (function(_super) {

    __extends(ParseError, _super);

    function ParseError() {
      return ParseError.__super__.constructor.apply(this, arguments);
    }

    return ParseError;

  })(ImtoError);

  precedence = {
    "+": 1,
    ".": 2
  };

  ParseNode = (function() {

    function ParseNode(options) {
      this.toString = __bind(this.toString, this);

      var p;
      for (p in options) {
        if (!__hasProp.call(options, p)) continue;
        this[p] = options[p];
      }
    }

    ParseNode.prototype.toString = function() {
      return printNode(this);
    };

    return ParseNode;

  })();

  BlockNode = (function(_super) {

    __extends(BlockNode, _super);

    function BlockNode() {
      this.parse = __bind(this.parse, this);
      return BlockNode.__super__.constructor.apply(this, arguments);
    }

    BlockNode.prototype.parse = function() {
      if (this.source != null) {
        return new Parser(new Lexer(this.source, {
          tracking: this.tracking
        }));
      } else {
        return new Cursor;
      }
    };

    return BlockNode;

  })(ParseNode);

  module.exports = Parser = (function(_super) {

    __extends(Parser, _super);

    function Parser(lexer) {
      this.lexer = lexer;
      this.execute = __bind(this.execute, this);

      this.local_assignment = __bind(this.local_assignment, this);

      this.hash_assignment = __bind(this.hash_assignment, this);

      this.assignment = __bind(this.assignment, this);

      this["function"] = __bind(this["function"], this);

      this.block = __bind(this.block, this);

      this.tidbit = __bind(this.tidbit, this);

      this.operator = __bind(this.operator, this);

      this.expr = __bind(this.expr, this);

      this.statement = __bind(this.statement, this);

      this.at = __bind(this.at, this);

      Parser.__super__.constructor.call(this);
      this.memo_index = -1;
      this.memos = [];
    }

    Parser.prototype.at = function(req_index) {
      while (this.memo_index < req_index) {
        if (!this.memos[this.memo_index += 1]) {
          this.memos[this.memo_index] = this.statement();
        }
      }
      return this.memos[req_index];
    };

    Parser.prototype.statement = function() {
      var expr, _ref2;
      while (((_ref2 = this.lexer.peek()) != null ? _ref2.type : void 0) === "linefeed") {
        this.lexer.next();
      }
      if (expr = this.expr()) {
        return new ParseNode(expr);
      } else {
        return void 0;
      }
    };

    Parser.prototype.expr = function() {
      var expr;
      expr = this.tidbit();
      expr = this.operator(expr) || expr;
      return expr;
    };

    Parser.prototype.operator = function(expr) {
      var node, operator, result;
      if ((expr != null) && (this.lexer.peek() != null) && this.lexer.peek().type === "operator") {
        operator = this.lexer.next();
        node = this.tidbit();
        if ((expr != null) && (this.lexer.peek() != null) && this.lexer.peek().type === "operator") {
          if ((precedence[this.lexer.peek().token] != null) && precedence[this.lexer.peek().token] > precedence[operator.token]) {
            node = this.operator(node);
          }
          result = {
            type: 'operator',
            left: expr,
            right: node,
            operator: operator.token,
            tracking: {
              start: expr.tracking.start,
              end: (node != null ? node : operator).tracking.end
            }
          };
          return this.operator(result) || result;
        }
        return {
          type: 'operator',
          left: expr,
          right: node,
          operator: operator.token,
          tracking: {
            start: expr.tracking.start,
            end: (node != null ? node : operator).tracking.end
          }
        };
      }
    };

    Parser.prototype.tidbit = function() {
      var expr, _ref2, _ref3;
      if ((_ref2 = (_ref3 = this.lexer.peek()) != null ? _ref3.type : void 0) === 'comma' || _ref2 === 'linefeed' || _ref2 === 'operator') {
        return void 0;
      }
      if (!expr) {
        expr = this.block() || this["function"]() || this.assignment() || this.execute() || (expr = this.lexer.next());
      }
      return expr;
    };

    Parser.prototype.block = function() {
      var n, subject, _ref2, _ref3, _ref4;
      if (((_ref2 = this.lexer.peek()) != null ? _ref2.type : void 0) === "block") {
        subject = this.lexer.next();
        return new BlockNode({
          type: "block",
          source: subject.source,
          tracking: {
            start: subject.tracking.start,
            end: subject.tracking.end
          }
        });
      }
      if (((_ref3 = this.lexer.peek()) != null ? _ref3.type : void 0) === "linefeed") {
        if (((_ref4 = this.lexer.peek(2)) != null ? _ref4.type : void 0) === "block") {
          subject = this.lexer.next(2);
          n = this.lexer.next();
          return new BlockNode({
            type: "block",
            source: n.source,
            tracking: {
              start: subject.tracking.start,
              end: n.tracking.end
            }
          });
        }
      }
    };

    Parser.prototype["function"] = function() {
      var node, subject, _ref2;
      if (((_ref2 = this.lexer.peek()) != null ? _ref2.type : void 0) === "function") {
        subject = this.lexer.next();
        node = this.expr();
        return {
          type: "function",
          body: node,
          signature: subject.source,
          tracking: {
            start: subject.tracking.start,
            end: node.tracking.end
          }
        };
      }
    };

    Parser.prototype.assignment = function() {
      return this.hash_assignment() || this.local_assignment();
    };

    Parser.prototype.hash_assignment = function() {
      var first, n, node, statements, subject, _ref2, _ref3, _ref4;
      if (((_ref2 = this.lexer.peek()) != null ? _ref2.type : void 0) === "symbol") {
        n = this.lexer.peek(2);
        if ((n != null ? n.token : void 0) === ":") {
          subject = this.lexer.next();
          this.lexer.next();
          node = this.expr();
          first = {
            type: "hash_assignment",
            symbol: subject.token,
            value: node,
            tracking: {
              start: subject.tracking.start,
              end: node.tracking.end
            }
          };
          if (((_ref3 = this.lexer.peek()) != null ? _ref3.token : void 0) === ',') {
            statements = [first];
            while (((_ref4 = this.lexer.peek()) != null ? _ref4.token : void 0) === ',') {
              this.lexer.next();
              node = this.hash_assignment();
              if (node == null) {
                throw new ParseError("Unfinished hash", {
                  tracking: this.lexer.prev(0).tracking.start
                });
              }
              statements.push(node);
            }
            return {
              type: "hash",
              statements: statements,
              tracking: {
                start: subject.tracking.start,
                end: node.tracking.end
              }
            };
          } else {
            return first;
          }
        }
      }
    };

    Parser.prototype.local_assignment = function() {
      var n, node, subject, _ref2;
      if (((_ref2 = this.lexer.peek()) != null ? _ref2.type : void 0) === "symbol") {
        n = this.lexer.peek(2);
        if ((n != null ? n.token : void 0) === "=") {
          subject = this.lexer.next();
          this.lexer.next();
          node = this.expr();
          return {
            type: "assignment",
            symbol: subject.token,
            value: node,
            tracking: {
              start: subject.tracking.start,
              end: node.tracking.end
            }
          };
        }
      }
    };

    Parser.prototype.execute = function() {
      var expr, params, subject, _ref2;
      if (((_ref2 = this.lexer.peek()) != null ? _ref2.type : void 0) === "symbol") {
        subject = this.lexer.next();
        params = [];
        while (expr = this.tidbit()) {
          params.push(expr);
          if (!((this.lexer.peek() != null) && this.lexer.peek().token === ",")) {
            break;
          }
          this.lexer.next();
        }
        return {
          type: 'execute',
          symbol: subject.token,
          params: params,
          tracking: {
            start: subject.tracking.start,
            end: (params.length > 0 ? params[params.length - 1] : subject).tracking.end
          }
        };
      }
    };

    return Parser;

  })(Cursor);

}).call(this);

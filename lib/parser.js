// Generated by CoffeeScript 1.3.3
(function() {
  var Cursor, Lexer, Parser,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Lexer = require('./lexer');

  Cursor = require('./Cursor');

  module.exports = Parser = (function(_super) {

    __extends(Parser, _super);

    function Parser(lexer) {
      this.lexer = lexer;
      this.local_assignment = __bind(this.local_assignment, this);

      this.property_assignment = __bind(this.property_assignment, this);

      this.assignment = __bind(this.assignment, this);

      this["function"] = __bind(this["function"], this);

      this.block = __bind(this.block, this);

      this.expr = __bind(this.expr, this);

      this.statement = __bind(this.statement, this);

      this.at = __bind(this.at, this);

      Parser.__super__.constructor.call(this);
      this.memo_index = -1;
      this.memos = [];
    }

    Parser.prototype.at = function(req_index) {
      while (this.memo_index < req_index) {
        if (!this.memos[this.memo_index += 1]) {
          this.memos[this.memo_index] = this.statement();
        }
      }
      return this.memos[req_index];
    };

    Parser.prototype.statement = function() {
      var subject;
      subject = this.lexer.next();
      while ((subject != null ? subject.type : void 0) === "linefeed") {
        subject = this.lexer.next();
      }
      return this.expr(subject);
    };

    Parser.prototype.expr = function(subject) {
      return this.block(subject) || this["function"](subject) || this.assignment(subject) || subject;
    };

    Parser.prototype.block = function(subject) {
      var n, _ref;
      if ((subject != null ? subject.type : void 0) === "block") {
        return {
          type: "block",
          source: subject.source,
          tracking: {
            start: subject.tracking.start,
            end: subject.tracking.end
          }
        };
      }
      if ((subject != null ? subject.type : void 0) === "linefeed") {
        if (((_ref = this.lexer.peek()) != null ? _ref.type : void 0) === "block") {
          n = this.lexer.next();
          return {
            type: "block",
            source: n.source,
            tracking: {
              start: subject.tracking.start,
              end: n.tracking.end
            }
          };
        }
      }
    };

    Parser.prototype["function"] = function(subject) {
      var node;
      if ((subject != null ? subject.type : void 0) === "function") {
        node = this.expr(this.lexer.next());
        return {
          type: "function",
          body: node,
          tracking: {
            start: subject.tracking.start,
            end: node.tracking.end
          }
        };
      }
    };

    Parser.prototype.assignment = function(subject) {
      return this.property_assignment(subject) || this.local_assignment(subject);
    };

    Parser.prototype.property_assignment = function(subject) {
      var n, node;
      if ((subject != null ? subject.type : void 0) === "symbol") {
        n = this.lexer.peek();
        if ((n != null ? n.token : void 0) === ":") {
          node = this.expr(this.lexer.next(2));
          return {
            type: "property_assignment",
            symbol: subject.token,
            value: node,
            tracking: {
              start: subject.tracking.start,
              end: node.tracking.end
            }
          };
        }
      }
      return null;
    };

    Parser.prototype.local_assignment = function(subject) {
      var n, node;
      if ((subject != null ? subject.type : void 0) === "symbol") {
        n = this.lexer.peek();
        if ((n != null ? n.token : void 0) === "=") {
          node = this.expr(this.lexer.next(2));
          return {
            type: "assignment",
            symbol: subject.token,
            value: node,
            tracking: {
              start: subject.tracking.start,
              end: node.tracking.end
            }
          };
        }
      }
    };

    return Parser;

  })(Cursor);

}).call(this);

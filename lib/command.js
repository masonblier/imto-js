// Generated by CoffeeScript 1.3.3
(function() {
  var Module, REPL_PROMPT, REPL_PROMPT_CONTINUATION, REPL_PROMPT_MULTILINE, Script, args, backlog, clc, error, imto, interpreter, mode, multilineMode, pipedInput, readline, repl, run, stdin, stdout,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  stdin = process.openStdin();

  stdout = process.stdout;

  imto = require('./index');

  readline = require('readline');

  Script = require('vm').Script;

  Module = require('module');

  clc = require('./utils').clc;

  REPL_PROMPT = clc.blue('imto> ');

  REPL_PROMPT_MULTILINE = clc.blue('----> ');

  REPL_PROMPT_CONTINUATION = clc.blue('....> ');

  error = function(err) {
    return stdout.write(clc.red(err.stack || err.toString()) + '\n');
  };

  process.on('uncaughtException', error);

  backlog = '';

  interpreter = new imto.Interpreter();

  run = function(buffer) {
    var returnValue;
    buffer = buffer.replace(/(^|[\r\n]+)(\s*)##?(?:[^#\r\n][^\r\n]*|)($|[\r\n])/, "$1$2$3");
    buffer = buffer.replace(/[\r\n]+$/, "");
    try {
      returnValue = (function() {
        switch (mode) {
          case 1:
            return (interpreter.lex(buffer)).all();
          case 2:
            return (interpreter.parse(buffer)).all();
          default:
            return interpreter["eval"](buffer);
        }
      })();
      repl.output.write("" + returnValue + "\n");
    } catch (err) {
      error(err);
    }
    return repl.prompt();
  };

  mode = 0;

  args = process.argv.splice(2);

  if (__indexOf.call(args, "-L") >= 0) {
    mode = 1;
  }

  if (__indexOf.call(args, "-P") >= 0) {
    mode = 2;
  }

  if (stdin.readable) {
    pipedInput = '';
    repl = {
      prompt: function() {
        return stdout.write(this._prompt);
      },
      setPrompt: function(p) {
        return this._prompt = p;
      },
      input: stdin,
      output: stdout,
      on: function() {}
    };
    stdin.on('data', function(chunk) {
      var line, lines, _i, _len, _ref;
      pipedInput += chunk;
      if (!/\n/.test(pipedInput)) {
        return;
      }
      lines = pipedInput.split("\n");
      pipedInput = lines[lines.length - 1];
      _ref = lines.slice(0, -1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        if (line) {
          run(line);
        }
      }
    });
    stdin.on('end', function() {
      var line, _i, _len, _ref;
      _ref = pipedInput.trim().split("\n");
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        if (!(line)) {
          continue;
        }
        stdout.write("" + line + "\n");
        run(line);
      }
      stdout.write('\n');
      return process.exit(0);
    });
  } else {
    if (readline.createInterface.length < 3) {
      repl = readline.createInterface(stdin);
      stdin.on('data', function(buffer) {
        return repl.write(buffer);
      });
    } else {
      repl = readline.createInterface(stdin, stdout);
    }
  }

  multilineMode = false;

  repl.on('attemptClose', function() {
    if (multilineMode) {
      multilineMode = false;
      repl.output.cursorTo(0);
      repl.output.clearLine(1);
      repl._onLine(repl.line);
      return;
    }
    if (backlog) {
      backlog = '';
      repl.output.write('\n');
      repl.setPrompt(REPL_PROMPT);
      return repl.prompt();
    } else {
      return repl.close();
    }
  });

  repl.on('close', function() {
    repl.output.write('\n');
    return repl.input.destroy();
  });

  repl.on('line', run);

  repl.setPrompt(REPL_PROMPT);

  repl.prompt();

}).call(this);

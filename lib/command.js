// Generated by CoffeeScript 1.3.3
(function() {
  var Module, REPL_PROMPT, REPL_PROMPT_CONTINUATION, REPL_PROMPT_MULTILINE, Script, args, backlog, enableColours, error, inspect, interpreter, mode, multilineMode, pipedInput, readline, redl, repl, run, stdin, stdout,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  stdin = process.openStdin();

  stdout = process.stdout;

  redl = require('./redl');

  readline = require('readline');

  inspect = require('util').inspect;

  Script = require('vm').Script;

  Module = require('module');

  REPL_PROMPT = 'redl> ';

  REPL_PROMPT_MULTILINE = '----> ';

  REPL_PROMPT_CONTINUATION = '....> ';

  enableColours = false;

  if (process.platform !== 'win32') {
    enableColours = !process.env.NODE_DISABLE_COLORS;
  }

  error = function(err) {
    return stdout.write((err.stack || err.toString()) + '\n');
  };

  process.on('uncaughtException', error);

  backlog = '';

  interpreter = new redl.Interpreter();

  run = function(buffer) {
    var returnValue;
    buffer = buffer.replace(/(^|[\r\n]+)(\s*)##?(?:[^#\r\n][^\r\n]*|)($|[\r\n])/, "$1$2$3");
    buffer = buffer.replace(/[\r\n]+$/, "");
    try {
      returnValue = (function() {
        switch (mode) {
          case 1:
            return interpreter.lex(buffer);
          default:
            return interpreter["eval"](buffer);
        }
      })();
      repl.output.write("" + (inspect(returnValue, false, 2, enableColours)) + "\n");
    } catch (err) {
      error(err);
    }
    return repl.prompt();
  };

  mode = 0;

  args = process.argv.splice(2);

  if (__indexOf.call(args, "-L") >= 0) {
    mode = 1;
  }

  if (stdin.readable) {
    pipedInput = '';
    repl = {
      prompt: function() {
        return stdout.write(this._prompt);
      },
      setPrompt: function(p) {
        return this._prompt = p;
      },
      input: stdin,
      output: stdout,
      on: function() {}
    };
    stdin.on('data', function(chunk) {
      var line, lines, _i, _len, _ref;
      pipedInput += chunk;
      if (!/\n/.test(pipedInput)) {
        return;
      }
      lines = pipedInput.split("\n");
      pipedInput = lines[lines.length - 1];
      _ref = lines.slice(0, -1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        if (!(line)) {
          continue;
        }
        stdout.write("" + line + "\n");
        run(line);
      }
    });
    stdin.on('end', function() {
      var line, _i, _len, _ref;
      _ref = pipedInput.trim().split("\n");
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        if (!(line)) {
          continue;
        }
        stdout.write("" + line + "\n");
        run(line);
      }
      stdout.write('\n');
      return process.exit(0);
    });
  } else {
    if (readline.createInterface.length < 3) {
      repl = readline.createInterface(stdin);
      stdin.on('data', function(buffer) {
        return repl.write(buffer);
      });
    } else {
      repl = readline.createInterface(stdin, stdout);
    }
  }

  multilineMode = false;

  repl.on('attemptClose', function() {
    if (multilineMode) {
      multilineMode = false;
      repl.output.cursorTo(0);
      repl.output.clearLine(1);
      repl._onLine(repl.line);
      return;
    }
    if (backlog) {
      backlog = '';
      repl.output.write('\n');
      repl.setPrompt(REPL_PROMPT);
      return repl.prompt();
    } else {
      return repl.close();
    }
  });

  repl.on('close', function() {
    repl.output.write('\n');
    return repl.input.destroy();
  });

  repl.on('line', run);

  repl.setPrompt(REPL_PROMPT);

  repl.prompt();

}).call(this);
